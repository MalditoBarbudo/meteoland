#' Fits Markov Chain Transition Matrices to State Sequence
#' Modified from weathergen
#' 
#' @param states character array of states (from {'d','w','e'}, for dry, wet and extremely wet)
#' @param months numeric array of months for each daily time step
#' @export
#' @return monthly list of transition matrices
#' @examples
#' transitions <- mc_fit(x=sample(c('d', 'w', 'e'), size=720, replace=TRUE, prob=c(0.5, 0.3, 0.2)), months=rep(rep(seq(1, 12), each=30), times=2))
#'
# 
.mc_fit<-function(states, months) {
  stopifnot(length(states) == length(months))
  ns <- 3
  s  <- c('d','w','e')
  states <- as.character(states)
  states_next <- c(states[2:length(states)],NA)
  transitions <- lapply(seq(1, 12), function(m) {
    idx <- which(months==m)
    t = matrix(0, 3,3,dimnames = list(s,s))
    for(i in 1:ns) for(j in 1:ns) t[i,j] = sum(states[idx]==s[i] & states_next[idx]==s[j], na.rm=T)
    t<-sweep(t, 1, rowSums(t, na.rm=T),"/")
    t[is.na(t)] <- 0
    t
  })
  transitions
}
#' Run Markov Chain Simulation
#'
#' @param months numeric array of months for each daily time step
#' @param initial initial state
#' @param transitions monthly list of transition matrices generated by mc_fit()
#' @export
#' @examples
#' transitions <- mc_fit(x=sample(c('d', 'w', 'e'), size=720, replace=TRUE, prob=c(0.5, 0.3, 0.2)), 
#'                       months=rep(rep(seq(1, 12), each=30), times=2))
#' mc_simulate(months=rep(1:12, each=30), initial='d', transitions=transitions, states=c('d', 'w', 'e'))
#'
.mc_sim<-function(months, initial, transitions) {
  n <- length(months)
  
  states <- as.character(rownames(transitions[[1]]))
  chain <- as.character(rep(NA, times=n))
  chain[1] <- as.character(initial)
  
  for (i in 2:n) {
    tm <- transitions[[months[i-1]]]
    p <- as.numeric(tm[which(states==chain[i-1]), ])
    chain[i] <- sample(states, size=1, prob=p)
  }
  return(chain)
}


#' Determine Markov State Thresholds from Precipitation
#'
#' @param x vector of daily precipitation
#' @param months vector of months corresponding to daily precipitation vector \code{x}
#' @param dry_wet_threshold threshold precipitation amount for dry/wet states
#' @param wet_extreme_quantile_threshold threshold quantile for wet/extreme states
#' @return monthly list of precipitation thresholds as vectors of length 2 
#' (first element is threshold amount between dry/wet, 
#' second element is threshold amount between wet/extreme)
.mc_state_threshold <- function(x, months, dry_wet_threshold=0.3, wet_extreme_quantile_threshold=0.8) {
  stopifnot(any(!is.na(x)))
  stopifnot(any(!is.na(months)))
  stopifnot(length(x) == length(months))
  
  thresh <- lapply(seq(1, 12), function(month) {
    idx <- which(months == month)
    if (length(idx) > 0) {
      x.month <- x[idx]
      res <- c(dry_wet=dry_wet_threshold, wet_extreme = max(dry_wet_threshold+0.1,
                                                       unname(quantile(x.month, probs=wet_extreme_quantile_threshold))))
    } else {
      res <- c(dry_wet=NA, wet_extreme=NA)
    }
    res
  })
  
  thresh
}

#' Assign Markov States from Precipitation and State Thresholds
#'
#' @param x vector of daily precipitation
#' @param months vector of months corresponding to daily precipitation
#' @param states character list of markov states
#' @param thresholds list of monthly transition matrices generated from mc_fit()
#' @export
.mc_assign_states <- function(x, months, thresholds) {
  stopifnot(length(x)==length(months))
  stopifnot(length(thresholds)==12)
  
  states <- c('d','w','e')
  state <- lapply(seq(1, 12), function(month) {
    idx <- which(months == month)
    if (length(idx) > 0) {
      x.month <- x[idx]
      res <- cut(x.month, breaks=c(0, thresholds[[month]], Inf), include.lowest=TRUE, right=TRUE, labels=states)
    } else {
      res <- character()
    }
    res
  })
  return(as.character(unlist(state)))
}

# Apipattanavis, S., G. Podesta, B. Rajagopalan, and R. W. Katz (2007), A
# semiparametric multivariate and multisite weather generator, Water
# Resour. Res., 43, W11401, doi:10.1029/2006WR005714.
weathergenerator<-function(x, params = defaultGenerationParams()) {
  months = as.numeric(format(as.Date(row.names(x)),"%m"))
  prec = x$Precipitation
  sd_prec = sd(prec)
  meantemp = x$MeanTemperature
  sd_meantemp = sd(meantemp)
  thresh <- .mc_state_threshold(prec, months, 
                                dry_wet_threshold = params$dry_wet_threshold, 
                                wet_extreme_quantile_threshold = params$wet_extreme_quantile_threshold)
  states <- .mc_assign_states(prec, months, thresh)
  statePrev <- c(NA, states[1:(length(states)-1)])
  transition <- .mc_fit(states, months)
  
  #Set variable weights
  w_prec = 100/sd_prec
  w_meantemp = 10/sd_meantemp

  #Initialize selected days
  initial <- sample(which(months == months[1]),1)
  #Generate Precipitation State Series of M day length
  pss <- .mc_sim(months, states[initial], transition)

  #Initialize vector of selected days
  days <-initial
  
  prevSelectedDay <- initial
  for(ic in 2:length(pss)) {
    # cat(paste0("ic", ic,":\n"))
    #Select days centered on the same DOY that have the same sequence of states simulated by the MC for day t and t-1
    rangeSize = 2
    sel = rep(FALSE, length(states))
    while(sum(sel)==0) {
      rangeSize = rangeSize+1
      doyIC = x$DOY[ic]
      doyrange <- (doyIC-rangeSize):(doyIC+rangeSize)
      doyrange[doyrange<0] <- (365 + doyrange[doyrange<0])
      sel = (x$DOY %in% doyrange) & (states == pss[ic]) & (statePrev == states[ic-1])
      sel[1] = FALSE
    }
    selDays <- which(sel)
    Q <- sum(sel)
    # cat(paste0("Q", Q,"rs", rangeSize,"\n"))
    k <- ceiling(sqrt(Q)) 
    #Calculate weighted euclidean distances
    dq <- sqrt(w_prec*((prec[prevSelectedDay] - prec[selDays-1])^2)+
               w_meantemp*((meantemp[prevSelectedDay] - meantemp[selDays-1])^2))
    o <- order(dq)
    sel_knn <- (dq <= dq[o[k]])
    selDays = selDays[sel_knn]
    dq = dq[sel_knn]
    o = order(dq)
    w_kernel <- (1/o)/sum(1/o)
    d <- selDays[sample(1:length(selDays), size=1, prob=w_kernel)]
    days = c(days, d)
    prevSelectedDay = d
  }
  y <- x[days, ]
  y$DOYold = y$DOY
  y$DOY = x$DOY
  row.names(y) = row.names(x)
  return(y)
}